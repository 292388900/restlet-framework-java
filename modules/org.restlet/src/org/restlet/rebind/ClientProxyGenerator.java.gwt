/**
 * Copyright 2005-2009 Noelios Technologies.
 * 
 * The contents of this file are subject to the terms of one of the following
 * open source licenses: LGPL 3.0 or LGPL 2.1 or CDDL 1.0 or CDL 1.0 (the
 * "Licenses"). You can select the license that you prefer but you may not use
 * this file except in compliance with one of these Licenses.
 * 
 * You can obtain a copy of the LGPL 3.0 license at
 * http://www.opensource.org/licenses/lgpl-3.0.html
 * 
 * You can obtain a copy of the LGPL 2.1 license at
 * http://www.opensource.org/licenses/lgpl-2.1.php
 * 
 * You can obtain a copy of the CDDL 1.0 license at
 * http://www.opensource.org/licenses/cddl1.php
 * 
 * You can obtain a copy of the EPL 1.0 license at
 * http://www.opensource.org/licenses/eclipse-1.0.php
 * 
 * See the Licenses for the specific language governing permissions and
 * limitations under the Licenses.
 * 
 * Alternatively, you can obtain a royalty free commercial license with less
 * limitations, transferable or non-transferable, directly at
 * http://www.noelios.com/products/restlet-engine
 * 
 * Restlet is a registered trademark of Noelios Technologies.
 */

package org.restlet.rebind;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;

import org.restlet.Request;
import org.restlet.Response;
import org.restlet.Uniform;
import org.restlet.data.Method;
import org.restlet.representation.ObjectRepresentation;
import org.restlet.representation.Representation;
import org.restlet.resource.Delete;
import org.restlet.resource.Get;
import org.restlet.resource.Post;
import org.restlet.resource.ClientProxy;
import org.restlet.engine.resource.GwtClientProxy;
import org.restlet.resource.ResourceException;

import com.google.gwt.core.client.GWT;
import com.google.gwt.core.ext.GeneratorContext;
import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.TreeLogger.Type;
import com.google.gwt.core.ext.typeinfo.JClassType;
import com.google.gwt.core.ext.typeinfo.JMethod;
import com.google.gwt.core.ext.typeinfo.JParameter;
import com.google.gwt.core.ext.typeinfo.JParameterizedType;
import com.google.gwt.core.ext.typeinfo.JPrimitiveType;
import com.google.gwt.core.ext.typeinfo.JType;
import com.google.gwt.core.ext.typeinfo.NotFoundException;
import com.google.gwt.core.ext.typeinfo.TypeOracle;
import com.google.gwt.user.client.rpc.AsyncCallback;
import com.google.gwt.user.client.rpc.SerializationStreamFactory;
import com.google.gwt.user.rebind.ClassSourceFileComposerFactory;
import com.google.gwt.user.rebind.SourceWriter;
import com.google.gwt.user.rebind.rpc.SerializableTypeOracle;
import com.google.gwt.user.rebind.rpc.SerializableTypeOracleBuilder;
import com.google.gwt.user.rebind.rpc.TypeSerializerCreator;

/**
 * Deferred binding generator capable of creating a subclass of
 * {@link GwtClientProxy} implementing a custom Java interface, extending
 * the marker {@link ClientProxy} interface, and annotated with Restlet
 * annotations such as {@link Get} , {@link Post} or {@link Delete}.
 * 
 * @author Jerome Louvel
 */
public class ClientProxyGenerator extends com.google.gwt.core.ext.Generator {

	private TreeLogger logger;

	private JClassType classType;

	private GeneratorContext context;

	private String className;

	private String packageName;

	private String typeQName;

	private SourceWriter sourceWriter;

	private TypeOracle typeOracle;

	private SerializableTypeOracleBuilder stob;

	private SerializableTypeOracle sto;

	/**
	 * Default constructor.
	 */
	public ClientProxyGenerator() {
		this.logger = null;
		this.classType = null;
		this.context = null;
		this.className = null;
		this.packageName = null;
		this.typeQName = null;
		this.sourceWriter = null;
		this.typeOracle = null;
		this.stob = null;
		this.sto = null;
	}

	@Override
	public String generate(TreeLogger logger, GeneratorContext context,
			String typeQName) throws UnableToCompleteException {
		String result = null;

		try {
			this.logger = logger;
			this.context = context;
			this.typeQName = typeQName;
			this.sourceWriter = null;
			this.typeOracle = context.getTypeOracle();
			this.classType = typeOracle.getType(typeQName);
			this.packageName = getClassType().getPackage().getName();
			this.className = getClassType().getSimpleSourceName() + "Proxy";
			generateProxy();
			result = getPackageName() + "." + getClassName();
		} catch (Exception e) {
			e.printStackTrace();
			UnableToCompleteException utce = new UnableToCompleteException();
			utce.initCause(e);
			throw utce;
		}

		return result;
	}

	protected void generateContructor() {
		println("public " + getClassName() + "() {");
		indent();
		println("super(GWT.getModuleBaseURL(),");
		indent();
		println("SERIALIZATION_POLICY, ");
		println("SERIALIZER);");
		outdent();
		outdent();
		println("}");
	}

	protected void generateFields(SerializableTypeOracle serializableTypeOracle) {
		String typeSerializerName = serializableTypeOracle
				.getTypeSerializerQualifiedName(getClassType());
		println("private static final String SERIALIZATION_POLICY =\"" + "null"
				+ "\";");
		println("private static final " + typeSerializerName
				+ " SERIALIZER = new " + typeSerializerName + "();");
	}

	protected void generateMethod(java.lang.reflect.Method method) throws Exception {
		AnnotationInfo info = AnnotationUtils.getAnnotation(method);

		if (info == null) {
			getLogger().log(
					Type.WARN,
					"The " + getTypeQName() + " interface contains a \""
							+ method.getName()
							+ "\" method without a proper Restlet annotation.");
		} else {
			int modifiers = method.getModifiers();
			if (Modifier.isPublic(modifiers)) {
				print("public ");
			} else if (Modifier.isPrivate(modifiers)) {
				print("private ");
			} else if (Modifier.isProtected(modifiers)) {
				print("protected ");
			}

			print("void " + method.getName() + "(");

			Class<?>[] parameterTypes = method.getParameterTypes();
			java.lang.reflect.Type[] genericParameterTypes = method
					.getGenericParameterTypes();
			Class<?> parameterType;
			java.lang.reflect.Type genericParameterType;
			ParameterizedType parameterizedType;
			Class<?> actualType = null;
			Class<?> callbackType = null;

			for (int i = 0; i < parameterTypes.length; i++) {
				parameterType = parameterTypes[i];
				genericParameterType = genericParameterTypes[i];
				parameterizedType = (genericParameterType instanceof ParameterizedType) ? (ParameterizedType) genericParameterType
						: null;

				if (parameterizedType != null) {
					actualType = (parameterizedType.getActualTypeArguments()[0] instanceof Class<?>) ? (Class<?>) parameterizedType
							.getActualTypeArguments()[0]
							: null;
				} else {
					actualType = null;
				}

				if (i == (parameterTypes.length - 1)) {
					if (AsyncCallback.class.isAssignableFrom(parameterType)) {
						callbackType = actualType;

						if (callbackType == null) {
							print("final " + parameterType.getSimpleName()
									+ " callback");
						} else {
							print("final " + parameterType.getSimpleName()
									+ "<" + callbackType.getName() + ">"
									+ " callback");
						}
					} else {
						getLogger()
								.log(
										Type.WARN,
										"The "
												+ getTypeQName()
												+ " interface contains a \""
												+ method.getName()
												+ "\" method without a callback as last parameter.");
					}
				} else {
					print(parameterType.getName() + " param" + (i + 1) + ", ");
				}
			}

			println("){");
			indent();

			if (parameterTypes.length > 1) {
				parameterType = parameterTypes[0];
				println("Representation requestEntity = new ObjectRepresentation<"
						+ parameterType.getName()
						+ ">(param1,(SerializationStreamFactory) "
						+ getClassName() + ".this);");
				println("getClientResource().getRequest().setEntity(requestEntity);");
			}

			println("getClientResource().setMethod(Method."
					+ info.getRestletMethod().toString() + ");");
			println("getClientResource().setOnReceived(new Uniform() {");
			indent();
			println("public void handle(Request request, Response response) {");
			indent();
			println("if (getClientResource().getStatus().isError()) {");
			indent();
			println("callback.onFailure(new ResourceException(getClientResource().getStatus()));");
			outdent();
			println("} else {");
			indent();

			if (Void.class.equals(callbackType)) {
				println("callback.onSuccess(null);");
			} else {
				println(callbackType.getName() + " result;");
				println("try {");
				indent();
				println("result = new ObjectRepresentation<"
						+ callbackType.getName() + ">(");
				indent();
				println("response.getEntity().getText(),");
				println("(SerializationStreamFactory) " + getClassName()
						+ ".this)");
				println(".getObject();");
				outdent();
				println("callback.onSuccess(result);");
				outdent();
				println("} catch (IOException ioe) {");
				indent();
				println("callback.onFailure(ioe);");
				println("}");
				outdent();
			}

			println("}");
			outdent();
			println("}");
			outdent();
			println("});");
			println("getClientResource().handle();");
			outdent();
			println("}");
		}
	}

	protected void generateProxy() throws Exception {
		PrintWriter printWriter = getContext().tryCreate(getLogger(),
				getPackageName(), getClassName());

		if (printWriter != null) {
			generateSerializers();

			ClassSourceFileComposerFactory composer = new ClassSourceFileComposerFactory(
					getPackageName(), getClassName());
			composer.setSuperclass(GwtClientProxy.class.getCanonicalName());
			composer.addImplementedInterface(getTypeQName());
			composer.addImport(GWT.class.getCanonicalName());
			composer.addImport(IOException.class.getCanonicalName());
			composer.addImport(Request.class.getCanonicalName());
			composer.addImport(Response.class.getCanonicalName());
			composer.addImport(Uniform.class.getCanonicalName());
			composer.addImport(Method.class.getCanonicalName());
			composer.addImport(Representation.class.getCanonicalName());
			composer.addImport(ObjectRepresentation.class.getCanonicalName());
			composer.addImport(ResourceException.class.getCanonicalName());
			composer.addImport(AsyncCallback.class.getCanonicalName());
			composer.addImport(SerializationStreamFactory.class
					.getCanonicalName());

			this.sourceWriter = composer.createSourceWriter(getContext(),
					printWriter);
			indent();
			println();
			generateFields(getSto());
			println();
			generateContructor();
			println();

			// Generate the proxy methods
			Class<?> interfaceClass = Class.forName(getTypeQName());

			for (java.lang.reflect.Method method : interfaceClass.getMethods()) {
				if (!"getClientResource".equals(method.getName())) {
					if ("void".equals(method.getReturnType().toString())) {
						generateMethod(method);
						println();
					} else {
						getLogger()
								.log(
										Type.WARN,
										"The "
												+ getTypeQName()
												+ " interface contains a \""
												+ method.getName()
												+ "\" method without a void return type.");
					}
				}
			}

			outdent();
			println("}");
			getContext().commit(getLogger(), printWriter);
		}
	}

	protected void generateSerializers() throws UnableToCompleteException {
		try {
			this.stob = new SerializableTypeOracleBuilder(getLogger(),
					getContext().getPropertyOracle(), getTypeOracle());

			// Discover and add serializable types
			getStob().addRootType(getLogger(),
					getTypeOracle().getType(String.class.getName()));
			JMethod[] methods = getClassType().getOverridableMethods();
			JClassType exceptionClass = getTypeOracle().getType(
					Exception.class.getName());
			JType asyncType = getTypeOracle().getType(
					AsyncCallback.class.getName());

			for (JMethod method : methods) {
				if (!"getClientResource".equals(method.getName())) {
					JType returnType = method.getReturnType();

					if (returnType != JPrimitiveType.VOID) {
						getStob().addRootType(getLogger(), returnType);
					}

					JParameter[] parameters = method.getParameters();
					for (JParameter parameter : parameters) {
						JType parameterType = parameter.getType();
						JParameterizedType parameterizedType = parameterType
								.isParameterized();

						if ((parameterizedType == null)
								|| (parameterizedType.getBaseType() != asyncType)) {
							getStob().addRootType(getLogger(), parameterType);
						}
					}

					JType[] exceptions = method.getThrows();
					if (exceptions.length > 0) {
						for (JType exception : exceptions) {
							if (!exceptionClass.isAssignableFrom(exception
									.isClass())) {
								getLogger()
										.log(Type.WARN,
												"Only checked exceptions are supported");
							}

							getStob().addRootType(getLogger(), exception);
						}
					}
				}
			}

			// Log serialization information
			OutputStream los = getContext().tryCreateResource(getLogger(),
					getClassType().getQualifiedSourceName() + ".restlet.log");
			getStob().setLogOutputStream(los);
			this.sto = getStob().build(getLogger());

			if (los != null) {
				getContext().commitResource(getLogger(), los).setPrivate(true);
			}

			TypeSerializerCreator tsc = new TypeSerializerCreator(getLogger(),
					getSto(), getContext(), getSto()
							.getTypeSerializerQualifiedName(getClassType()));
			tsc.realize(getLogger());
		} catch (NotFoundException e) {
			getLogger().log(TreeLogger.ERROR, "", e);
			throw new UnableToCompleteException();
		}
	}

	protected String getClassName() {
		return className;
	}

	protected JClassType getClassType() {
		return classType;
	}

	protected GeneratorContext getContext() {
		return context;
	}

	protected TreeLogger getLogger() {
		return logger;
	}

	protected String getPackageName() {
		return packageName;
	}

	protected SourceWriter getSourceWriter() {
		return sourceWriter;
	}

	protected SerializableTypeOracle getSto() {
		return sto;
	}

	protected SerializableTypeOracleBuilder getStob() {
		return stob;
	}

	protected TypeOracle getTypeOracle() {
		return typeOracle;
	}

	protected String getTypeQName() {
		return typeQName;
	}

	protected void indent() {
		getSourceWriter().indent();
	}

	protected void outdent() {
		getSourceWriter().outdent();
	}

	protected void print(String value) {
		getSourceWriter().print(value);
	}

	protected void println() {
		getSourceWriter().println();
	}

	protected void println(String value) {
		getSourceWriter().println(value);
	}

}
