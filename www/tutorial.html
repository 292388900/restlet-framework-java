<html>
<head>
 <style type="text/css">
/* <![CDATA[ */
@import "http://www.restlet.org/stylesheets/tigris.css";
/*  ]]> */
 </style>
 <title>Restlet - Tutorial</title>
</head>
<body>

<a target="_top" href="http://www.restlet.org"><img src="http://www.restlet.org/images/logo200"/></a><br/>

<br/>

<h1>Tutorial</h1>
<br/>

<h3><a name="toc">Table of contents</a></h3>
<p>
   <ol>
      <li><a href="#part01">Registering the Restlet implementation</a></li>
      <li><a href="#part02">Retrieving the content of a Web page</a></li>
      <li><a href="#part03">Listening to Web browsers</a></li>
      <li><a href="#part04">Overview of a REST architecture</a></li>
      <li><a href="#part05">Restlets servers and containers</a></li>
      <li><a href="#part06">Serving static files</a></li>
      <li><a href="#part07">Chainlets and call logging</a></li>
      <li><a href="#part08">Displaying error pages</a></li>
      <li><a href="#part09">URI rewriting and redirection</a></li>
      <li><a href="#part10">Maplets and hierarchical URIs</a></li>
      <li><a href="#part11">Conclusion</a></li>
   </ol>
</p>
<br/>

<h3><a name="part01">1. Registering the Restlet implementation</a></h3>

<p>
   The Restlet framework is composed of two parts. First, there is the "<a href="http://www.restlet.org/docs/api/">Restlet API</a>", a neutral API supporting the concepts of REST and a mechanism called Restlet facilitating the handling of REST calls. This API must be supported by a "Restlet Implementation" before it can effectively be used. Multiple implementations could be provided (open source projects, commercial products).
</p>
<p>
   This separation between the API and the implementation is similar to the one between the Servlet API and Web containers like Jetty or Tomcat, or between the JDBC API and actual JDBC drivers. Currently, only the "<a href="http://www.restlet.org/docs/nre/">Noelios Restlet Engine</a>" (NRE) is available and acts as the reference implementation. When you download the Restlet framework, the API and the NRE come bundled together, ready to be used. You only need to add the following line before starting to use the framework:
</p>
<pre>
         // Registering a Restlet API implementation
         com.noelios.restlet.Engine.register();
</pre>
<p>
   Internally, the implementation registers itself by calling back the <code>org.restlet.Manager.registerFactory()</code>.
</p>
<br/>

<h3><a name="part02">2. Retrieving the content of a Web page</a></h3>

<p>
   As we mentionned in the <a target="_top" href="http://www.restlet.org/introduction">introduction paper</a>, the Restlet framework is at the same time a client and a server framework. For example, NRE can easily work with remote resources using its HTTP client connector. A connector in REST, is a sofware component that enables the communication between components, typically by implementing one side of a network protocol. Here we will get the representation of an existing resource and output it in the JVM console:
</p>
<pre>
         // Outputting the content of a Web page
         HttpClient client = new HttpClient("My Web client");
         client.doGet("http://www.restlet.org").getOutput().write(System.out);
</pre>
<p>
   Note that the example above uses a simplified way to issue calls via the HttpClient. A more flexible way is to create a new REST call and to ask the HTTP client to handle it. In order to do that, we will use the Manager class, which also has a factory role. The example below could be a good basis to set some preferences in your call, like a referrer URI, the languages and media types you prefer to receive as a response:
</p>
<pre>
         // Prepare the REST call
         UniformCall call = Manager.createCall();
         Reference uri = Manager.createReference("http://www.restlet.org");
         call.setResourceRef(uri);
         call.setMethod(Methods.GET);

         // Ask to the HTTP client connector to handle the call
         HttpClient client = new HttpClient("My Web client");
         client.handle(call);

         // Output the result representation on the JVM console
         Representation output = call.getOutput();
         output.write(System.out);
</pre>
<br/>

<h3><a name="part03">3. Listening to Web browsers</a></h3>

<p>
   Now, we want to see how the Restlet framework can listen to client requests and reply to them. We will use the NRE HTTP server connector (supported by Mortbay's Jetty HTTP listener) and return a simple string representation "Hello World!" as plain text. Note that in a more realistic application, we would probably create a new handler class implementing UniformInterface instead of creating the instance on the fly.
</p>
<pre>
         // Creating a minimal handler returning "Hello World"
         UniformInterface handler = new UniformInterface()
         {
            public void handle(UniformCall call)
            {
               call.setOutput(new StringRepresentation("Hello World!", MediaTypes.TEXT_PLAIN));
            }
         };

         // Create the HTTP server and listen on port 8182
         new JettyServer("My Web server", 8182, handler).start();
</pre>
<p>
   If you run this code and launch your server, you can open a Web browser and hit the <a target="_top" href="http://localhost:8182">http://localhost:8182</a>. Actually, any URI will work, try also <a target="_top" href="http://localhost:8182/test/tutorial">http://localhost:8182/test/tutorial</a>. The handler that we created is very primitive and only takes advantage of the pure REST part of the Restlet framework. We will see later how to take advantage of the Restlets in order to facilitate this processing.
</p>
<br/>

<h3><a name="part04">4. Overview of a REST architecture</a></h3>
<p>
   Let's step back a little bit and consider a typical web architecture from a REST point of view. In the diagram below, circles represent the connector that enable the communication between components which are represented by the boxes. The blue links represents the network communication using a particular protocol (HTTP, SMTP, etc.).
</p>
<p>
   <img src="http://www.restlet.org/images/tutorial04" alt="REST architecture"/>
</p>
<p>
   Note that the same component can have any number of client and server connectors attached to it. Web Server B, for example, has both a server connector to respond to requests from the User Agent component, and client connectors to send requests to the Database Server, the Mail Server and the Web Server A.
</p>
<br/>

<h3><a name="part05">5. Restlets servers and containers</a></h3>
<p>
   In addition to supporting the standard REST software architecture elements as presented before, the Restlet framework also provides a set of components that facilitate the handling of REST calls. The goal is to provide a powerful and RESTful alternative to existing Servlet frameworks.
<p/>
<p>
   First, we can use Restlets which are simple call handlers living inside a parent Restlet container. Restlets are selected when the URI of the requested resource matches a given URI pattern. In order to see how to reply to client requests, we will attach a Restlet (myRestlet) to a parent container (myContainer). In order for a Web client to invoke the Restlet, the following URI will have to be entered: <a href="http://localhost:8182/trace">http://localhost:8182/trace</a>.
</p>
<pre>
         // Create a new Restlet container
         RestletContainer myContainer = new DefaultRestletContainer("My container");

         // Create the HTTP server connector, then add it as a server connector
         // to the Restlet container. Note that the container is the call handler.
         JettyServer httpServer = new JettyServer("My connector", 8182, myContainer);
         myContainer.addServer(httpServer);

         // Create a new Restlet that will display some path information.
         Restlet myRestlet = new AbstractRestlet(myContainer)
            {
               public void handle(RestletCall call) throws RestletException
               {
                  // Print the requested URI path
                  String output = "Resource path = " + call.getPath(0, false) + '\n' +
                                  "Restlet  path = " + call.getPath(1, false);

                  call.setOutput(new StringRepresentation(output, MediaTypes.TEXT_PLAIN));
               }
            };

         // Then attach it to the container.
         myContainer.attach("http://localhost:8182/trace", myRestlet);

         // Now, let's start the container!
         // Note that the HTTP server connector is also automatically started.
         myContainer.start();
</pre>
<p>
   Now, if your web application is becoming more complex, you may want to use multiple Restlet containers, all living within a single Restlet server. For example, this is very useful if you want to separate you domain resources (managed by container C) from your web server resources (managed by container A) and your web services resources (managed by container B):
</p>
<p>
   <img src="http://www.restlet.org/images/tutorial05" alt="Restlet servers and containers"/>
</p>
<p>
   Also, note that servers and containers are REST components themselves. This means that if your Restlet server has only one container, you can simply use it as your origin server and attach connectors normally to it.
</p>
<br/>

<h3><a name="part06">6. Serving static files</a></h3>
<p>
   Do you have a part of your web application that serves static pages like Javadocs? Well, no need to setup an Apache server just for that, the Noelios Restlet Engine provides a dedicated Restlet called DirectoryRestlet. See how simple it is to use it:
</p>
<pre>
         // Create a directory Restlet able to return a deep hierarchy of Web files
         // (HTML pages, CSS stylesheets or GIF images) from a local directory.
         DirectoryRestlet dirRestlet = new DirectoryRestlet(myContainer, "D:/Restlet/www/docs/api/", true, "index");
         dirRestlet.addExtension("html", MediaTypes.TEXT_HTML);
         dirRestlet.addExtension("css", MediaTypes.TEXT_CSS);
         dirRestlet.addExtension("gif", MediaTypes.IMAGE_GIF);

         // Then attach the Restlet to the container.
         // Note that virtual hosting can be very easily supported if you need it,
         // just attach multiple Restlets, one for each virtual server.
         myContainer.attach("http://localhost:8182/", dirRestlet);
</pre>
<p>
   <img src="http://www.restlet.org/images/tutorial06" alt="Call handling flow"/><br/>
</p>
<p>
   Note that no external configuration file is needed. Here, the three extensions are declaring some media types, but the same mechanism can also be used to declare other metadata like languages.
</p>
<br/>

<h3><a name="part07">7. Chainlets and call logging</a></h3>
<p>
   Being able to properly log the activity of a Web application is a common requirement. NRE has a class called the LoggerChainlet that knows how to generate Apache-like logs. By taking advantage of the logging facility built in the JDK, the logger can be configured like any standard JDK log to filter messages, reformat them and specify where to send them. Rotation of logs is also supported, see the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/logging/package-summary.html">java.util.logging</a> package for details.
</p>
<p>
   Chainlets are specialized Restlets that filter calls passed to them, without modifying the requested resource URI. If you are familiar with the Servlet API, the concept is similar to the <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/Filter.html">Filter</a> interface. Below is a simple example adding the logging facility to the previous example:
</p>
<pre>
         // Attach a logger Chainlet to the container
         LoggerChainlet logger = new LoggerChainlet(myContainer, "com.noelios.restlet.tutorial");
         myContainer.attach("http://localhost:8182/", logger);

         // Create a directory Restlet able to return a deep hierarchy of Web files
         DirectoryRestlet dirRestlet = new DirectoryRestlet(myContainer, "D:/Restlet/www/docs/api/", true, "index");
         dirRestlet.addExtension("html", MediaTypes.TEXT_HTML);
         dirRestlet.addExtension("css", MediaTypes.TEXT_CSS);
         dirRestlet.addExtension("gif", MediaTypes.IMAGE_GIF);

         // Then attach the Restlet to the logger Chainlet.
         logger.attach(dirRestlet);
</pre>
<p>
   <img src="http://www.restlet.org/images/tutorial07" alt="Call handling flow"/><br/>
</p>
<p>
   Note that "com.noelios.restlet.tutorial" is the log name as given to the java.util.logging classes. You will need to set the configuration location, for example by calling:
</p>
<pre>
         System.setProperty("java.util.logging.config.file", "/your/path/logging.config");
</pre>
<p>
   For details on the configuration file format, please check the <a href="http://java.sun.com/j2se/1.5.0/docs/api/index.html?java/util/logging/LogManager.html">JDK's LogManager</a> class.
</p>
<br/>

<h3><a name="part08">8. Displaying error pages</a></h3>
<p>
   Another common requirement is the ability to customize the status pages returned when something didn't go as expected during the call handling. Maybe a resource was not found or an acceptable representation isn't available? In this case, or when any unhandled exception must be intercepted, the StatusChainlet can be used. Here we will simply attach one between the logger Chainlet and the directory Restlet:
</p>
<pre>
         // Attach a logger Chainlet to the container
         LoggerChainlet logger = new LoggerChainlet(myContainer, "com.noelios.restlet.tutorial");
         myContainer.attach("http://localhost:8182/", logger);

         // Attach a status Chainlet to the logger Chainlet
         StatusChainlet status = new StatusChainlet(myContainer, true, "webmaster@mysite.org", "http://www.mysite.org");
         logger.attach(status);

         // Create a directory Restlet able to return a deep hierarchy of Web files
         DirectoryRestlet dirRestlet = new DirectoryRestlet(myContainer, "D:/Restlet/www/docs/api/", true, "index");
         dirRestlet.addExtension("html", MediaTypes.TEXT_HTML);
         dirRestlet.addExtension("css", MediaTypes.TEXT_CSS);
         dirRestlet.addExtension("gif", MediaTypes.IMAGE_GIF);

         // Then attach the Restlet to the status Chainlet.
         status.attach(dirRestlet);
</pre>
<p>
   <img src="http://www.restlet.org/images/tutorial08" alt="Call handling flow"/><br/>
</p>
<p>
   In order to customize the default messages, you will simply need to subclass the StatusChainlet class and override the getRepresentation(status, call) method.
</p>
<br/>

<h3><a name="part09">9. URI rewriting and redirection</a></h3>
<p>
   One of the advantage of the Restlet framework is the built-in support for <a href="http://www.w3.org/Provider/Style/URI">cool URIs</a>. Another good description of the importance of proper URI design is given by Jacob Nielsen in his <a href="http://www.useit.com/alertbox/990321.html">AlertBox</a>. The first tool available is the RedirectRestlet, which allows the rewriting of a cool URI to another URI, followed by an automatic redirection. Several types of redirection are supported, the external redirection via the client/browser, the internal redirection at the container level and the connector redirection for proxy-like behavior. In the example below, we will define a search service for our web site (named "mysite.org") based on Google. The "/search" relative URI identifies the search service, accepting some keywords via the "query" parameter. :
</p>
<pre>
         // Create a redirect Restlet then attach it to the container
         String target = "http://www.google.com/search?q=site:mysite.org+${query[\"query\"]}";
         RedirectRestlet searchRedirect = new RedirectRestlet(myContainer, target, RedirectRestlet.MODE_CLIENT_TEMPORARY);
         myContainer.attach("http://localhost:8182/search", searchRedirect);
</pre>
<p>
   <img src="http://www.restlet.org/images/tutorial09" alt="Call handling flow"/><br/>
</p>
<p>
   Note that the RedirectRestlet needs two parameters only. The first one defines how the URI rewriting should be done, based on a URI template. This template will be processed by the <a href="http://www.restlet.org/docs/nre/com/noelios/restlet/util/StringTemplate.html">StringTemplate</a> class and the URI data model provided by the <a href="http://www.restlet.org/docs/nre/com/noelios/restlet/util/RestletCallModel.html">RestletCallModel</a> class. The second parameter defines the type of redirection, here we chose the client redirection, for simplicity purpose.
</p>
<br/>

<h3><a name="part10">10. Maplets and hierarchical URIs</a></h3>
<p>
   In addition to the RedirectRestlet, we have another tool to manage cool URIs, especially the hierarchical ones. Maplets are specialized Restlets that can have other Restlets (or Maplets or Chainlets) attached to them and that can automatically delegate calls based on a URI pattern. Note that Restlet containers are also Maplets, so your already used them to attach Restlets to "myContainer".
</p>
<p>
   Here we want to explain how to handle the following URIs:
   <ol>
      <li>/docs/* to display static files</li>
      <li>/users/$userName to display a user account</li>
      <li>/users/$userName/orders to display the orders of a particular user</li>
   </ol>
   The fact that these URIs contain some dynamic parts and that no file extension is used makes it harder to handle them in a typical Web container. Here we will simply rely on a tree of Maplets. In the processing flow below, you can see that when a call is received by the container (1), it is first filtered by two Chainlets (2) and (3), then it reaches the RootMaplet. If the URI starts with /docs/ then the DirectoryRestlet will get the call (5), if it starts with /users then it is for the UsersMaplet, otherwise an error is returned to the client (404, not found).
</p>
<p>
   When a call reaches the UsersMaplet (6) we try to match the remaing part of the URI against the "/[a-z]+" pattern, representing a valid log name. If a match is found, then the UserMaplet is invoked (7). At that point it is possible to get the login name, because Maplets automatically build a list of all the URI parts matched during the delegation, just invoke "call.getPath(1, true)". Finally, if the "/orders$" URI pattern is matched, the OrdersRestlet is invoked (8), where we can still get the login name by calling "call.getPath(2, true)". Note that we use the '$' character at the end of the pattern in order to make sure that we match "/users/%userName%/orders" but not "/users/%userName%/orders123".
</p>
<p>
   <img src="http://www.restlet.org/images/tutorial10" alt="Call handling flow"/><br/>
</p>
<p>
   See the implementation code below. In a real application, you will probably want to create separate subclasses instead of the anonymous ones we use here:
</p>
<pre>
         // Attach a logger Chainlet to the container
         LoggerChainlet logger = new LoggerChainlet(myContainer, "com.noelios.restlet.tutorial");
         myContainer.attach("http://localhost:8182", logger);

         // Attach a status Chainlet to the logger Chainlet
         StatusChainlet status = new StatusChainlet(myContainer, true, "webmaster@mysite.org", "http://www.mysite.org");
         logger.attach(status);

         // Attach a root Maplet to the status Chainlet.
         Maplet rootMaplet = new DefaultMaplet(myContainer);
         status.attach(rootMaplet);

         // Create a directory restlet able to return a deep hierarchy of Web files
         DirectoryRestlet dirRestlet = new DirectoryRestlet(myContainer, "D:/Restlet/www/docs/api/", true, "index");
         dirRestlet.addExtension("html", MediaTypes.TEXT_HTML);
         dirRestlet.addExtension("css", MediaTypes.TEXT_CSS);
         dirRestlet.addExtension("gif", MediaTypes.IMAGE_GIF);
         rootMaplet.attach("/docs/", dirRestlet);

         // Create the users maplet
         Maplet usersMaplet = new DefaultMaplet(myContainer);
         rootMaplet.attach("/users", usersMaplet);

         // Create the user maplet
         Maplet userMaplet = new DefaultMaplet(myContainer)
            {
               public void handle(RestletCall call) throws RestletException
               {
                  // Print the requested URI path
                  String output = "Account of user named: " + call.getPath(1, true);
                  call.setOutput(new StringRepresentation(output, MediaTypes.TEXT_PLAIN));
               }
            };
         usersMaplet.attach("/[a-z]+", userMaplet);

         // Create the orders Restlet
         Restlet ordersRestlet = new AbstractRestlet(myContainer)
            {
               public void handle(RestletCall call) throws RestletException
               {
                  // Print the requested URI path
                  String output = "Orders of user named: " + call.getPath(2, true);
                  call.setOutput(new StringRepresentation(output, MediaTypes.TEXT_PLAIN));
               }
            };
         userMaplet.attach("/orders$", ordersRestlet);
</pre>
<br/>

<h3><a name="part11">11. Conclusion</a></h3>
<p>
   We already covered many aspects of the framework. Before you move on by yourself, let's take a step back and look at some hierarchy diagrams showing the main concepts covered in this tutorial. Note that interfaces have a lighter background than the concrete classes. Abstract classes have their name in italics:
</p>
<p>
   <img src="http://www.restlet.org/images/tutorial11" alt="Hierarchy diagrams"/><br/>
</p>

<p>
   Beside this tutorial, your best source of information will be the Javadocs available for both the <a href="http://www.restlet.org/docs/api/">API</a> and the <a href="http://www.restlet.org/docs/nre/">NRE</a>. You can also post your questions and help others via the <a href="http://www.restlet.org/discuss">discussion list</a>.
</p>

<p>
   <a href="mailto:contact@noelios.com">J&eacute;r&ocirc;me Louvel</a> (<a target="_top" href="http://blog.noelios.com">blog</a>)<br/>
</p>

<h4>Notes</h4>
<p>
   <ul>
      <li>I encourage you to run the examples. The full source code is available in the latest release.
      <li>Thanks to <a target="_top" href="http://www.figer.com/">Jean-Paul Figer</a>, Christian Jensen and Jim Ancona for the feed-back on this tutorial.</li>
   </ul>
</p>

<br/>

<small>
   Version 2.1, last modified on 2005/12/29<br/>
   Copyright &copy; 2005 J&eacute;r&ocirc;me Louvel. Restlet is a trademark and service mark of <a target="_top" href="http://www.noelios.com">Noelios Consulting</a>.
</small>

</body>
</html>
